import os

import matplotlib.pyplot as plt

from gdorks.audio_text import extract_text
from noise import noise_up


class MyTestCase:
    """
    tests google speech to text api efficiency on 10 audio files
    that were edited by adding an Additive White Gaussian Noise
    """
    # these are the expected texts, None represents the sounds i could not hear
    human_original_audio_answers = ["Animals are heterotrophic.", "To allow female workers", "The email users manage.",
                                    "You see something like that.",
                                    "He had a beautifully.", None, "Actually just going.", "Energy helps reducing.",
                                    "Are overdesign.",
                                    "Competitive skills comparison."]
    # these are the expected texts for edited audio files, None represents the sounds i could not hear
    human_edited_audio_answers = ["Animals are heterotrophic.", "To allow female workers", "The email users manage.",
                                  "You see something like that.",
                                  "He had a beautifully.", None, "Actually just going.", None,
                                  "Are overdesign.",
                                  "Competitive skills comparison."]

    def read_files(self, add_noise: bool = False) -> list:
        L = []
        for filename in os.listdir(os.path.join(os.curdir, "originals")):
            file = os.path.join(os.path.join(os.curdir, "originals"), filename)
            if add_noise:
                file = noise_up(file)
            L.append(''.join(str(e) for e in extract_text(file)))
            if add_noise:
                os.remove(file)
        return L

    def originals_engine_efficiency(self) -> float:
        original_audios_engine_answers = self.read_files()
        counter = 0
        for i in range(len(self.human_original_audio_answers)):
            if original_audios_engine_answers[i] == self.human_original_audio_answers[i]:
                counter += 1
        return counter / (len(self.human_original_audio_answers) - 1)  # one audio was not understood by humans

    def edited_engine_efficiency(self) -> float:
        edited_audios_engine_answers = self.read_files(add_noise=True)
        counter = 0
        for i in range(len(self.human_original_audio_answers)):
            if edited_audios_engine_answers[i] == self.human_original_audio_answers[i]:
                counter += 1
        return counter / (len(self.human_edited_audio_answers) - 1)  # exclude audios i could not understand

    def human_efficiency(self, original: bool = True) -> float:
        if original:
            return sum(map(lambda string: string is not None, self.human_original_audio_answers)) / len(
                self.human_original_audio_answers)
        return sum(map(lambda string: string is not None, self.human_edited_audio_answers)) / len(
            self.human_edited_audio_answers)

    def plot(self, original: bool = True, both: bool = False):
        if both:
            self.plot(original=False)
            self.plot(original=True)
            return
        titles = ['Human', 'Google Speech Recognition API']
        values = [self.human_efficiency(original) * 100]
        if original:
            values.append(self.originals_engine_efficiency() * 100)
        else:
            values.append(self.edited_engine_efficiency() * 100)
        p = plt.bar(titles, values)
        for i in p:
            position = (i.get_x() + i.get_width() / 2, i.get_height() + 1)
            plt.annotate(str("%.2f" % i.get_height()) + "%",
                         position,
                         ha="center",
                         fontsize=10
                         )
        plt.ylim([0, 100])
        plt.xlabel("Engines")
        if original:
            plt.ylabel("Efficiency For Original Audio Files")
        else:
            plt.ylabel("Efficiency For Edited Audio Files")
        plt.show()


if __name__ == '__main__':
    MyTestCase().plot(both=True)
